

## 第一章 并发编程的挑战

**目的：**为了让程序运行更快。

### 1.1 上下文切换

CPU通过时间片分配算法，从保存上一个任务到再加载下一个任务的过程就是一次上下文切换。

#### 1.1.1 多线程一定快吗

不一定，并发执行累计不超过百万次时，串行比并行快，因为线程有创建和上下文切换的开销。

#### 1.1.3 如何减少山下文切换

- **无锁并发编程：**减少锁使用。如将数据ID按照hash取模分段，不同线程处理不同的段数据。
- **CAS算法：**Java中Atomic包，不需要加锁。
- **使用最少线程：**避免创建不必要的线程。
- **协程：**在单线程里实现多任务的调度和上下文切换。

### 1.2 死锁

两个或以上线程竞争资源或彼此通信，造成永远相互等待的阻塞现象。

**常见减少死锁方法**：

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，保证一个锁只占用一个资源
- 使用定时锁，tryLock(timeout)来代替内部锁机制
- 对于数据库锁，加锁和解锁必须在同一个连接里，否则会出现解锁失效

```java
public class DeadLockDemo {

    private static String A = "A";
    private static String B = "B";

    public static void main(String[] args) {
        new DeadLockDemo.deadLock();
    }

    private void deadLock() {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (A) {
                    Thread.currentThread().sleep(2000);
                    synchronized (B) {
                        System.out.println("1");
                    }
                }
            }
        });
        Thread t2 = new Thread(new Runnable(){
            @Override
            public void run() {
                synchronized(B) {
                    Thread.currentThread().sleep(2000);
                    synchronized(A) {
                        System.out.println("2");
                    }
                }

            }
        });

        t1.start();
        t2.start();
    }
}
```















**分时调度：**
轮流使用cpu使用权，平均分配每个线程占用cpu的时间；

**抢占式调度：**
优先级较高的使用cpu，如果线程优先级相同，随机选择一个，**java使用的为抢占式调度**。



**主线程** ：执行主方法（main）的线程。JVM执行main方法会进入栈内存中，jvm会找操作系统开辟一条main方法通向cpu的执行路径，cpu就可以通过路径来执行main方法。

的，

继承Thread类，重写run方法：

```java
class Son extends Dad {
   	String nickName;
   	Son(String nickName){
   		this.nickName = nickName;
   	}
   	public void run() {
   		//TODO
   	}
}
```

创建并启动一个线程：

```java
Son s = new Son("大头");
s.start();
```

调用start方法，开启新的线程，执行run方法。结果是两个线程并行。多次start一个线程是非法的，特别是当线程结束运行后，不能再重新启动。


对于CPU而言，多线程意味着有多条执行路径，意味着CPU有选择权

main方法压栈执行

![avatar](https://cdn.jsdelivr.net/gh/mans8/Image-Hosting/java/1571077848674.png)



两种创建方法
1.继承Thread类，重写run方法
启动直接调用start()方法
2.实现Runnable接口，实现run方法
Person p = new Person();
new Thread(p).start();

1.避免了单继承的局限性
2.增强程序的扩展性，降低了程序的耦合性，把设置线程任务和开启新线程进行了分离



匿名内部类实现线程的创建
匿名：没有名字
内部类：卸载其它类内部的类

作用：简化代码
```java
new Thread(){
	@Override
	public void run(){
		System.out.println("");
	}
}.start();
```

```java
new Thread(new Runnable() {
	@Override
	public void run() {
		System.out.println("");
	}
}).start();
```

### 1.2.2 线程同步

使用了一个锁对象，这个锁对象叫同步锁，也叫对象锁、对象监视器。

同步技术的原理总结：同步中的线程，没有执行完毕不会释放锁；同步外的线程，没有锁进不去同步。

- 好：保证只有一个线程在同步中操作共享数据

- 坏：频繁判断锁、获取锁、释放锁，效率降低

**同步的方法有三种：同步代码块、同步方法、锁机制。**

### 1.2.3 同步代码块

同步代码块：用在方法某个区块中，对区块的资源进行互斥访问


```java
synchronized(锁对象) {
    获取锁对象进入同步块中执行
	需要同步操作的代码（可能出现现成安全问题的代码）
    执行完同步归还锁对象
}
```

- 锁对象可以使用**任意对象**（这个对象可以跟代码块无关）

- 必须保证多个线程使用的锁对象是同一个

- 锁对象的作用是把代码块锁住，只让一个线程在同步代码块中执行

### 1.2.4 同步方法

简单讲就是把访问共享数据的代码抽取一个方法，用synchronized修饰。

*延伸：静态同步方法*

```java
private static int ticket = 100;
public static synchronized void buy(){
    xxx;
}
静态同步方法的锁对象不能是this
而是本类的class属性 --> class文件映射（反射）
```

### 1.2.5 Lock锁

​		JDK1.5之后出现lock接口，就是`java.util.concurrent.locks.Lock`接口。使用Lock比synchronized可获得更广泛的锁定操作。

```java
Lock lock = new ReentrantLock();//1.在成员变量位置创建ReentrantLock对象
@Override
public void run(){
    代码;
    lock.lock();//2.在有线程安全的代码前调用Lock.lock()获取锁
    try{
        有线程安全问题代码;
    }catch(){
        
    }finally{s
        lock.unlock();//3.在有线程安全的代码后调用Lock.unlock()释放锁
    }
    代码;
}
```



### 1.3 线程的状态

new：至今尚未启动的线程处于这种状态；

runnable：正在Java虚拟机中执行的线程处于这种状态；

blocked：受阻塞并等待监视器锁的线程处于这种状态；

waiting：无限期等待另一个线程来执行某一特定操作的线程处于这种状态；（无限等待）

timed_waiting：等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态；（计时等待）

terminated：已退出的线程处于这种状态。



等待唤醒案例

```java
Object obj = new Object();
new Thread(){
    @Override
    public void run(){
        synchronized(obj){
            doSth();
            obj.wait();
            doSth();
        }
    }
}
new Thread(){
    @Override
    public void run(){
        synchronized(obj){
            doSth();
            obj.notify();//调用wait的时候用obj，调用nofity的时候也要用obj
            			//唤醒之后继续执行wait之后的代码
        }
    }
}
//中断的方法在同步块内，此刻已经不持有锁，需要重新尝试获取锁，所以notify后不是立即执行
```

进入TimeWaiting计时等待的两种方式

```java
sleep(毫秒数);//到点后进入Runnable或Blocked状态
wait(毫秒数);//如果中间没有被notify唤醒，到点后自动醒，进入Runnable或Blocked状态
```

唤醒的方法有两种

```java
synchronized(obj){
    obj.notify();//唤醒在此对象监视器上等待的单个线程（随机一个）
    onj.notifyAll();//唤醒在此对象监视器（对象锁）上等待的所有线程
}
```

线程为什么要通信？

协调通信，达到多线程共同操作同一份数据。



如何保证线程间通信有效利用资源？

需要一定的手段，就是等待唤醒机制。（生产一个包子吃一个包子）





## 第二章 并发机制的底层实现原理

### 2.1 volatile的应用

官方定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

修饰变量，每个线程看到的值都是一样的，成本低，不会引起线程上下文切换

volatile修饰>>>写操作时会多出第二行代码0x01a3de24: lock addl $0 x 0, (%esp);>>>lock会引起处理器缓存写回主内存>>>缓存写回主内存会导致其它处理器同一个数据缓存失效>>>其它处理器操作此数据时要从主内存中读取



处理器如何保证单个CPU缓存和主内存数据一致？

单个处理器通过嗅探主内存，主内存中数据发生修改，单个处理器把自身缓存中的这个数据设为无效。

在新处理器中lock一般不锁总线，锁缓存，并写回主内存，使用缓存一致性来保证原子性，成为“缓存锁定”，缓存一致性会制止同时修改两个或以上处理器缓存的内存区域数据。



### 2.2 synchronized实现原理与应用



**锁住了什么？**

1.对于普通方法，锁住当前实例对象；

2.对于静态同步方法，锁住当前类的Class对象；

3.对于同步方法块，锁的是Synchronized括号里配置的对象。

**怎么锁？**

1.任何对象都有一个monitor对象；

2.对于同步代码块，在编译时，在同步代码块开始位置插入monitorenter，在方法结束处和异常位置插入monitorexit，jvm会保证enter和exit配对；

3.与对象关联的monitor被持有后，它将处于锁定状态。



#### 2.2.1 对象头

synchronized用的锁是存放在Java对象头里的。



非数组对象32/64位：

| 长度        | 内容                   | 说明                         |
| ----------- | ---------------------- | ---------------------------- |
| 32bit/64bit | Mark Word              | 存储对象的hashCode或者锁信息 |
| 32bit/64bit | Class Metadata Address | 存储到对象类型数据的指针     |

数组对象32/64位：

| 长度        | 内容                   | 说明                         |
| ----------- | ---------------------- | ---------------------------- |
| 32bit/64bit | Mark Work              | 存储对象的hashCode或者锁信息 |
| 32bit/64bit | Class Metadata Address | 存储到对象类型数据的指针     |
| 32bit/64bit | Array length           | 存储数组长度                 |



#### 2.2.2 锁的升级与对比

锁有四种状态（SE1.6）：无锁状态、偏向锁状态、轻量级锁、重量级锁

锁级别能升不能讲

| 锁       | 优点                          | 缺点                               | 适用场景                     |
| -------- | ----------------------------- | ---------------------------------- | ---------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗    | 线程间锁竞争会带来额外锁撤销的消耗 | 单线程同步块                 |
| 轻量级锁 | 竞争线程不会阻塞，响应快      | 等不到锁的线程会自旋消耗CPU        | 求响应快，同步块响应速度快   |
| 重量级锁 | 线程竞争不会自旋，不会消耗CPU | 线程阻塞，响应慢                   | 求吞吐量大，同步块响应速度慢 |



**偏向锁：**

偏向锁获取：当一个线程访问同步块获取锁时，会在对象头和栈帧的锁记录中，存放其偏向的线程ID，以后该线程退出或进入同步块时不需要进行CAS来加锁和解锁，只需简单测试对象头的mark word里是否存储着指向当前线程的偏向锁；

偏向锁撤销：等到竞争出现才释放；

关闭偏向锁：JVM参数-XX:-UseBiasedLocking=false，程序默认进入轻量级锁  





### 2.3 原子操作的实现原理

#### 2.3.2 处理器如何实现原子操作

处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

**总线锁定**

提供一个LOCK #信号，当一个处理器在总线上输出此信号时，其它处理器的请求被阻塞，该处理器独占共享内存。



**缓存锁定**

在某一个时刻，保证对某个内存地址的的操作是原子性，缓存一致性协议会阻止同时修改两个以上处理器缓存的内存区域数据。写回主内存存时，不在总线上声言LOCK#信号，而是修改内部的内存地址。



**什么情况不能使用缓存锁定？**

1.处理器不支持；

2.当操作的数据不能缓存在处理器内部，或者操作的数据跨多个缓存行（cache line是缓存的最小操作单位）。

**开销：**锁总线>锁缓存（总线锁定会把CPU和总线的通信锁住）



#### 2.3.3 java如何实现原子操作

使用锁或循环CAS。

**使用锁：**JVM内部实现了很多种锁机制，除了偏向锁，其它锁都使用了循环CAS来获取和释放锁。

**循环CAS：**

```java
/**使用CAS实现线程安全计数器**/
private AtomicInteger atomicI = new AtomicInteger(0);
private void safeCount() {
    for (;;) {
        int i = atomicI.get();
        boolean suc = atomicI.compareAndSet(i, ++i);
        if (suc) {
            break;
        }
    }
}

/**非线程安全**/
private int i = 0;
public void count() {
    count++;
}
```

**CAS实现原子操作的三大问题**

1.ABA问题

2.循环时间开销大

3.只能保证一个共享变量的原子操作



## 第三章 Java内存模型

### 3.1 Java内存模型的基础

#### 3.1.1 并发编程模型的两个关键问题

线程之间如何通信？

线程之间如何同步？



在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。



并发共享内存模型：读取共享内存，隐式通信；(Java采用/)

并发消息传递模型：发消息，显示通信。



#### 3.1.3 从源代码到指令序列的重排序

从源码到最终指令序列经历3种排序：

1.编译器优化重排序；（不改变单线程语义的前提下）

2.指令级并行重排序；（现代处理器采用指令集并行技术，将多条指令重叠执行）

3.内存系统重排序。（处理器使用缓存和读写缓冲区）



#### 3.1.4 并发编程模型的分类

 

**背景：**现代处理器的写缓冲区会临时保存向内存写入的数据，以批处理的方式刷新主内存，以及合并对同一地址的多次写，减少对内存总线的占用。现代处理器都使用写缓冲区，允许写-读进行重排序。

**引发问题：**这种批量/合并写仅对它所在的处理器可见（**引出内存可见性**），其它处理器不知道合并刷新。导致处理器对内存的读写顺序，不一定与实际执行顺序一致。



为了保证内存可见性，适当插入内存 ，禁止处理器指令重排序



#### 3.1.5 happens-before规则简介

​	JDK5开始使用JSR-133，在JMM中，如果一个操作需要对另一个操作可见，那么这两个操作之间必须存在 happens-before关系。

​	happens-before指的是执行结果可见，不是前个操作必须要在后操作之前执行。

​	与程序员密切相关的happens-before规则：

- 程序顺序规则：线程中每个操作，happens-before与线程中的任意后续操作；
- 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁；
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；
- 传递性：A h-b B 且B h-b C，则A h-b C。

### 3.2 重排序

​	重排序是指**编译器和处理器**为了**优化程序性能**对**指令序列进行重新排序**的行为



#### 3.2.1 数据依赖性

​	两操作访问同一变量，其中一操作为写，这两个操作存在数据依赖性。

​	编译器和处理器重排序时会遵守数据依赖性，不改变其依赖顺序。仅对单线程、单个处理器而言。

#### 3.2.2 as-if-serial语义

​	as-if-serial是指不管怎么重排序，（单线程）执行结果不变。

#### 3.2.3 程序顺序规则

​	计算机软硬件有一个共同目标：在不改变程序执行结果的前提现下，尽可能提供并行度。



### 3.3 顺序一致性

​	是一个理论模型。处理器内存模型和编程语言的内存模型都会**以顺序一致性模型作为参照**。

#### 3.3.1 数据竞争与数据一致性

​	Java对数据竞争定义：一个线程写同一个变量，一个线程读同一个变量，而且写和读没有同步来排序。（这里的同步指的是广义上同步，包括对常用同步原语synchronized、volatile和final的正确使用）	

#### 3.3.2 顺序一致性内存模型

​	**两大特性：**

- ​	一个线程必须程序的顺序来执行；

- ​	所有线程只能看到单一的操作执行顺序，每个操作原子执行且对所有线程可见。

  通俗讲，把所有线程读写操作**串行化**。

注意：JMM中未同步的程序执行顺序是无序的，所有线程看到的操作执行顺序也可能不一致。



   ### 3.4 volatile的内存语义

#### 3.4.1 volatile的特性

​	用来做同步。

​	**volatile变量两个特性：**

- ​	可见性（保证）：变量读写对所有线程可见；
- ​	原子性（不保证）：对单个volatile变量的读/写具有原子性，但volatile++这种复合操作不具有原子性。 （++是又读又写）

##### 3.4.4 volatile内存语义试下

​	在编译器生成字节码时，插入内存屏障，禁止不同处理器重排序。

| 是否能重排序 | 第二个操作  | 第二个操作 | 第二个操作    |
| :----------: | ----------- | ---------- | :------------ |
|  第一个操作  | 普通读 / 写 | volatile读 | volatile写    |
| 普通读 / 写  |             |            | no（1）       |
|  volatile读  | no（3、4）  | no（3、4） | no（1、3、4） |
|  volatile写  |             | no（2）    | no（1、2）    |

​	**规律：**

- ​	第一个为volatile读时，不管第二个是什么，都不能重排序；
- ​	第二个为volatile写时，不管第一个是什么，都不能重排序；
- ​	第一个为volatile写，第二个为volatile读时，不能重排序。

​	**基于保守策略的JVM内存屏障插入：**

- ​	在每个**volatile写**操作的**前**面插入一个**StoreStore**屏障；
- ​	在每个**volatile写**操作的**后**面插入一个**StoreLoad**屏障；
- ​	在每个**volatile读**操作的**后**面插入一个**LoadLoad**屏障；
- ​	在每个**volatile读**操作的**后**面插入一个**LoadStore**屏障；

*注意：X86仅会对写-读操作重排序，省略三种内存屏障，JMM仅需在volatile写后面插入一个StoreLoad屏障即可确实现。意味着X86的volatile写比volatile读开销大很多。*



#### 3.4.5 JSR-133为什么要增强volatile的内存定义

| 对比项                       | 旧内存模型                   | JSR-133                    |
| ---------------------------- | ---------------------------- | -------------------------- |
| volatile写-读和锁的释放-获取 | 内存语义不同                 | 内存语义相同               |
| 保证原子性范围               | 仅保证单个volatile读写原子性 | 保证临界区代码执行有原子性 |

增强目的：提供一种比锁更轻量级的线程之间的通信。

增强内容：使**volatile写-读**和**锁的释放-获取**具有相同的内存语义。

在功能上，锁更强大；在可伸缩性上，volatile更有优势。



### 3.5 锁的内存含义



#### 3.5.1 锁的释放-获取建立的happens-before关系

​	锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息（通过主内存）。



#### 3.5.2 锁的释放与获取的内存含义

​	当线程释放锁，把线程对应的本地内存刷到主内存；

​	当线程获取锁，把线程对应的本地内存设置为无效；

​	被监视器保护的临界区代码必须从主内存中读取共享变量。



#### 3.5.3 锁的内存语义实现

​	AQS（AbstractQueuedSynchronized）;

​	CAS（compareAndSet）；

​	AQS使用**一个整型的volatile变量（命名为state）来维护同步状态**，这个变量是ReentrantLock内存语义实现的关键。

**共享变量：**A写state前可见的共享变量，在B获得锁读取同一个state后，对B可见。

ReentrantLock锁分公平和非公平；

|                                       | lock()和unlock()方法轨迹（ReentrantLock lock = new ReentrantLock()） |
| ------------------------------------- | ------------------------------------------------------------ |
| 公平锁获取锁lock.lock()               | ReentrantLock : lock()<br />FairSync : lock()<br />AbstractQueuedSynchronizer : acquire(int arg)<br />//第四步真正加锁<br />ReentranLock : tryAcquire(int acquires) |
| 非公平锁获取锁lock.lock()             | ReentrantLock : lock()<br />NonfairSync : lock()<br />//第三步真正加锁<br />AbstractQueuedSynchronizer : compareAndSetState(int expect,int update) |
| 公平与非公平锁<br />释放锁lock.lock() | ReentrantLock : unlock()<br />AbstractQueuedSynchronizer : release(int arg)<br />Sync : tryReleases(int releases) |

|          | 获取                                                         | 释放                            |
| -------- | ------------------------------------------------------------ | ------------------------------- |
| 公平锁   | 首先会去读volatile变量                                       | 最后都要写一个volatile变量state |
| 非公平锁 | 首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存含义 | 最后都要写一个volatile变量state |

锁释放-获取的内存语义的实现至少有下面两种方式：

- 利用volatile变量的写 - 读所具有的内存语义；
- 利用CAS所附带的volatile读和volatile写的内存含义。

JDK中说CAS同时具有volatile读和volatile写的内存含义。



#### 3.5.4 concurrent包的实现

​	Java的**CAS**会**使用**现代处理器上提供的**高效机器级别的原子指令**，这些指令以原子方式对内存执行读 - 改 - 写，这-1是多处理器实现同步的关键。现代处理器都会支持某种能对内存执行原子性读 - 改 - 写操作的原子指令。

**concurrent包**的源码实现有**一个通用的实现模式**：

- 首先声明共享变量为volatile；
- 使用CAS的原子条件更新来实现线程间的同步；
- 配合volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程间的通信。

![](C:\Users\Administrator\Pictures\markdown\并发编程的艺术\concurrent包实现示意图_看图王.png)



### 3.6 final域的内存语义

​	与锁和volatile相比，对final域的读和写更像是普通变量的访问。



#### 3.6.1 final域的重排序规则

​	对于final域，编译器和处理器要遵守两个重排序规则：

- ​	在构造函数内对一个final域写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；
- ​	初次读一个包含final域的对象引用，与随后初次读这个final域，这两个操作之间不能重排序。



#### 3.6.2 写final域的重排序规则=+

​	**写final域的重排序规则禁止把final域的写重排序到构造函数之外**，包含两方面：

- ​	JMM禁止编译器把final域的写重排序到构造函数之外；
- ​	编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。

**确保：**在对象引用为任意线程可见                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

#### 3.6.3 读final域的重排序规则

​	在一个线程中，**初次读独享引用**与**初次读该对象包含的final域**，**JMM禁止处理器重排序这两个操作**（这个规则仅针对处理器），编译器会在读final域操作的前面插入一个LoadLoad屏障。

**确保**：对一个对象的final域之前，一定会先读包含这个final域的对象引用。



#### 3.6.7 JSR-133为什么要增强final定义

--通过final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没哟“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在函数中被初始化之后的值。



### 3.7 happens-before

#### 3.7.1 JMM的设计



#### 3.7.2 happens-before的定义

JSR-133使用happens-before来**指定两个操作之间的执行顺序**。不同操作可能不在同一线程内，JMM通过happens-before关系向程序员**提供跨线程的内存可见性**。



### 3.8 双重检查锁定与延迟初始化

延迟初始化：降低初始化类和创建对象的开销。

#### 3.8.1 双重检查锁定的由来

大幅降低synchronized带来的性能开销。

**优点：**

- 多个线程视图在同一时间创建对象时，会通过加锁来保证只有一个线程床架对象。
- 在对象创建好后，执行getInstance()方法将不需要后去锁，直接返回已经创建好的对象。

**缺点：**

- 这是一个错误的优化，线程执行到第4行，不为null时，instance引用的对象可能没完成初始化。

```java
public class DoubleCheckedLocking {
    private static Instance instance;
    public static Instance getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedLocking.class){
                if (instance == null) {
                    instance = new Instance();
                }
            }
        }
        return instance;
    }
}
```

#### 3.8.2 问题根源

instance = new Instance();   可以分解成如下伪代码：

```
memory = allocate();  //1.分配对象内存空间
ctorInstance(memory); //2.初始化对象
instance = memory;    //3.设置instance指向分配的内存地址
```



#### 3.8.3 基于volatile的解决方案

把instance声明为volatile的解决方案，就可以实现线程安全的延迟初始化。

```java
public class DoubleCheckedLocking {
    //使用volatile修饰，伪代码2和3步骤在多线程中禁止重排序
    private volatile static Instance instance;
    public static Instance getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedLocking.class){
                if (instance == null) {
                    instance = new Instance();
                }
            }
        }
        return instance;
    }
}
```



#### 3.8.4 基于类初始化的解决方案



### 3.9 Java内存模型概述



## 第四章 Java并发编程打基础



### 4.1 线程简介



#### 4.1.1 什么是线程

操作系统调度的最小单元，也叫轻量级进程（Light weight process）。线程有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。

#### 4.1.2 为什么要使用多线程

1. 更多的处理核心：处理器从更高主频向更多核心发展；
2. 更快的响应时间：可以使用多线程技术，将数据一致性不强的操作派给其它线程处理；
3. 更好的编程模型：提供一致的多线程编程模型，是开发人员专注业务。

#### 4.1.3 线程优先级

决定线程需要多或者少分配一些处理器资源的线程属性。

整型变量priority来控制优先级，范围从1-10，线程构建时可以通过set；；；  Priority(int)方法来修改优先级，默认优先级是，优先级高的线程分配时间片的数量要多于优先级低的线程。

#### 4.1.4 线程的状态

六种状态，同一时间线程只能处于其中一个状态

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| new          | 初始状态，线程被构建，但是还没调用start()方法                |
| runnable     | 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中” |
| blocked      | 阻塞状态，表示线程阻塞于锁                                   |
| waiting      | 等待状态，等待线程进入等待状态，进入该状态表示当前线程需要等待其它线程作出一些特定的动作（通知或中断） |
| time_waiting | 超时等待状态，该状态不同于waiting，它是可以在指定的时间运行返回的 |
| terminated   | 终止状态，表示当前线程已经执行完毕。                         |

![avatar](https://cdn.jsdelivr.net/gh/mans8/Image-Hosting/java/java线程状态变迁.png)

1. 线程创建后，调用start()方法进行运行。
2. 当线程**执行wait(**)方法之后，线程进入**等待状态**。
3. 进入**等待状态**的线程**需要**依靠其它线程的**通知**才能够**返回到运行**状态。
4. **超时等待**相当于在等待状态的基础上**增加了超时限制**，超时时间到达会返回运行状态。
5. 线程调用同步方法时，**没有获取到**锁的情况下，线程进入**阻**塞。
6. 线程在执行Runnable的run()方法后将进入**终止状态**。

> 阻塞在synchronized是阻塞，阻塞在concurrent包中的Lock是等待

#### 4.1.5 Daemon线程

一种支持型线程，用作后台调度和支持性工作。



### 4.2 启动和终止线程

#### 4.2.1 构造线程

父线程（parent）对新构造的子线程（child）进行空间分配，子线程继承父线程的属性，分配一个唯一id来识别此子线程。

#### 4.2.2 启动线程

初始化完成后调用start()方法可以启动此线程。

start方法是当前线程同步告知java虚拟机，只要线程规划器空闲，因立即启动调用start()方法的线程。

#### 4.2.3 理解中断

中断可以理解为线程的**一个的标识位属性**，它表示一个运行中的线程是否被其它线程进行了中断操作。

isInterrupted()来进行判断是否被中断。

Thread.interrupted()静态方法对当前线程的中断标识位进行复位。

抛出InterruptedException之前，java虚拟机会先将该线程的中断标识位清除。

#### 4.2.4 过期的suspend()暂停、resume()恢复、stop()终止

不推荐使用，会引起死锁。

suspend不会释放已占有的资源（比如锁）进入睡眠，会引起死锁。

stop终结一个线程时不会保证线程的资源正常释放，工作在不确定状态。

suspend和resume可以用等待/通知机制来替代。

#### 4.2.5 安全地终止线程

利用一个boolean变量on=true/false来控制是否需要停止任务并终止该线程。通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地讲线程停止，此做法更加安全和优雅。



### 4.3 线程间通信

线程开始运行，拥有自己的栈空间，按照既定的代码，一步一步地执行。

#### 4.3.1 volatile和synchronized关键字

多线程同时访问一个变量或者对象的成员变量，每个线程都可以拥有这个变量的拷贝，所以程序执行过程中，一个线程看到的变量并不一定是最新的。

> 虽然对象以及成员变量分配的内存是在共享内存中，但是每个执行的线程都有一份拷贝，这样的目的是加速程序的执行。

**volatile：修饰成员变量，保证可见性，读的时候必须从共享内存中读取，写的时候必须同步刷新到共享内存中。**

过多使用降低效率

**synchronized：修饰方法者同步块，保证统同一时刻只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。**

本质都是对一个对象的监视器进行获取，而这个获取的过程是排他的，也就是同一时刻只能有一个线程获取到synchronized所保护对象的监视器。 

获取不到对象监视器，就会阻塞在同步队列（synchronized queen）中。

![avatar](https://cdn.jsdelivr.net/gh/mans8/Image-Hosting/java/对象、监视器、同步队列和执行线程之间的关系.png)

#### 4.3.2 等待/通知机制

多线程之间通信的基本方式。

简单的循环检查对象值变化的缺点：

- 难以确保及时性
- 难以降低开销



**等待/通知的相关方法（定义在超类java.lang.Object上）：**

| 方法名称        | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| notify()        | 通知一个在对象上等待的线程从wait()方法返回，而返回的前提是该线程获得了对象的锁 |
| notifyAll()     | 通知所有等待在该对象上的线程                                 |
| wait()          | 调用该方法的线程进入waiting状态，只有等待另外线程的通知或中断才会返回，调用 |
| wait(long)      | 超时等待一段时间，这里的参数时间是毫秒，如果没有通知就超时返回 |
| wait(long, int) | 对于超时时间更细粒度的控制，可以达到纳秒                     |

1. 线程A调用了对象O的wait()方法，进入等待状态；
2. 线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知从对象O的wait()方法返回；
3. 上述两个线程通过对象O来完成交互，如同排队等号叫号。

**等待/通知的细节：**

1. 使用上述五个方法**需要先对调用对象加锁**
2. 调用wait()后线程状态从**running变成waiting**，进入对象等待队列
3. notify()和notifyAll()被调用后不会立即从wait()返回，**需要调用notify()和notifyAll()的线程释放锁后才会从wait()返回**
4. notify()将一个等待线程从等待队列中移到同步队列中，notifyAll()将等待队列中的所有等待线程移到同步队列，被移动的线程状态有**waiting变为blocked**
5. 从**wait()方法返回的前提是获得了调用对象的锁**



#### 4.3.3 等待/通知的经典范式

范式分为两部分：等待方（消费者）和通知方（生产者）

**等待方遵循如下原则：**

1. 获取对象的锁
2. 如果条件不允许，那么调用对象的wait()方法，被通知后仍要检查条件
3. 条件满足则执行对应逻辑

```java
synchronized( 对象 ) {
	while( 条件不满足 ) {
		对象.wait();
	}
	对应的处理逻辑
}
```

**通知方遵循如下原则**：

1. 获得对象的锁
2. 改变条件
3. 通知所有等待在对象上的线程

```
synchronized( 对象 ) {
	改变条件;
	对象.notifyAll();
}
```

#### 4.3.4 管道输入/输出



#### 4.3.5 Thread.join()的使用

thread.join()含义：当前线程A等待thread线程终止之后才从thread.join()返回。

#### 4.3.6 ThreadLocal的使用

key-value结构，ThreadLocal即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。



## 第五章 Java中的锁

![avatar](https://cdn.jsdelivr.net/gh/mans8/Image-Hosting/java/java锁.png)



### 5.1 Lock接口

 1.乐观锁、悲观锁

乐观锁

锁实现：关键字synchronized、接口Lock实现类

适用场景：写多读少

悲观锁

锁实现：CAS算法，例如AtomicInteger类原子自增是同过CAS自旋实现

适用场景：读多写少



CAS算法：compare and swap，比较与交换

无锁算法：基于硬件原语实现，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。

JDK实现：java.util.concurrent包中的原子类（AutomicInteger）就是通过CAS来实现了乐观锁

ABA问题：AtomicStampedReference在变量前面添加版本号，每次变量更新的时候都把版本号加1



2.死锁



3.排它锁（独占锁、互斥锁），共享锁



4.轻量级锁，轻量级锁



5.偏向锁



6.公平锁，非公平锁



7.读锁，写锁



8.重入锁，非可重入锁



9.行级锁，表锁，页锁，库锁



10.自旋锁，非自旋锁



11.无锁



12.分段锁（ConcurrentHashMap）





悲观锁与乐观锁是一种广义的概念，体现的是看待线程同步的不同角度。

悲观锁：悲观锁认为自己在使用

乐观锁：





### 5.2 队列同步器（AQS）

​		构建锁或者其他同步组件的基础框架，使用了一个int变量表示同步状态，通过内置的FIFO队列来完成对资源获取线程的排队工作。

​		AbstractQueuedSynchronizer是一个抽象了，自身没有实现任何同步接口。

​		同步器是实现锁或任意同步组件（ReentrantLock、ReentrantReadWriteLock、CountdownLock）的关键，在锁的实现中聚合同步器，利用同步器实现锁的定义。**锁和同步器关系：锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待、唤醒等底层操作。**



#### 5.2.1 队列同步器的接口与示例

同步器的设计是基于模板方法模式，步骤：

- 继承同步器；
- 重写指定方法；
- 将同步器组合在自定义同步组件的实现中；
- 调用同步器提供的模板方法，这些模板方法将会调用使用者重写的方法。

重写指定方法时，需要使用同步器提供的三个方法来访问或修改同步状态：

- getState()：获取当前同步状态；
- setState(int newState)：设置当前同步状态；
- compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。

### 5.3 重入锁